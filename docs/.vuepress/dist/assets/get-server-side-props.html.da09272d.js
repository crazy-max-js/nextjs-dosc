import{_ as e,o as s,c as a,a as n}from"./app.1ad2624e.js";const t={},p=n(`<h1 id="getserversideprops" tabindex="-1"><a class="header-anchor" href="#getserversideprops" aria-hidden="true">#</a> getServerSideProps</h1><p>如果您getServerSideProps从页面导出一个名为（服务器端渲染）的函数，Next.js 将使用getServerSideProps.</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getServerSideProps</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// will be passed to the page component as props</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>请注意，无论呈现类型如何，任何<code>props</code>都将传递给页面组件，并且可以在初始 HTML 中的客户端上查看。这是为了让页面正确补水。确保您不传递任何不应在客户端上可用的敏感信息<code>props</code>。</p></blockquote><h2 id="getserversideprops-什么时候运行" tabindex="-1"><a class="header-anchor" href="#getserversideprops-什么时候运行" aria-hidden="true">#</a> getServerSideProps 什么时候运行</h2><p><code>getServerSideProps</code>只在服务器端运行，从不在浏览器上运行。如果页面使用<code>getServerSideProps</code>，则：</p><ul><li>当你直接请求这个页面时，<code>getServerSideProps</code>在请求的时候运行，这个页面会和返回的 props 一起预渲染</li><li>当您在客户端页面转换通过<code>next/link</code>或请求此页面时<code>next/router</code>，Next.js 向服务器发送 API 请求，服务器运行<code>getServerSideProps</code></li></ul><p><code>getServerSideProps</code>返回将用于呈现页面的 JSON。所有这些工作都会由 Next.js 自动处理，所以你不需要做任何额外的事情，只要你<code>getServerSideProps</code>定义好了。</p><p>您可以使用next-code-elimination 工具来验证 Next.js 从客户端包中消除了什么。</p><p><code>getServerSideProps</code>只能从页面导出。您不能从非页面文件中导出它。</p><p>请注意，您必须导出为独立函数——如果您添加为页面组件的属性，<code>getServerSideProps</code>它将不起作用。<code>getServerSideProps</code></p><p><code>getServerSideProps</code>API 参考涵盖了所有可以与<code>getServerSideProps</code>.</p><h2 id="我什么时候应该使用-getserversideprops" tabindex="-1"><a class="header-anchor" href="#我什么时候应该使用-getserversideprops" aria-hidden="true">#</a> 我什么时候应该使用 getServerSideProps</h2><p><code>getServerSideProps</code>仅当您需要呈现必须在请求时获取其数据的页面时才应使用。这可能是由于数据的性质或请求的属性（例如<code>authorization</code>标头或地理位置）造成的。使用的页面将在请求时在服务器端呈现，并且仅在配置了缓存控制标头<code>getServerSideProps</code>时才被缓存。</p><p>如果您在请求期间不需要渲染数据，那么您应该考虑在客户端或<code>getStaticProps</code>.</p><h3 id="getserversideprops-或-api-路由" tabindex="-1"><a class="header-anchor" href="#getserversideprops-或-api-路由" aria-hidden="true">#</a> getServerSideProps 或 API 路由</h3><p>当您想从服务器获取数据时，可能很容易使用API 路由<code>getServerSideProps</code>，然后从. 这是一种不必要且低效的方法，因为它会由于<code>getServerSideProps</code>服务器上运行的 API 路由和 API 路由而导致发出额外的请求。</p><p>举个例子。API 路由用于从 CMS 获取一些数据。然后直接从 调用该 API 路由<code>getServerSideProps</code>。这会产生额外的调用，从而降低性能。相反，直接将 API 路由中使用的逻辑导入<code>getServerSideProps</code>. 这可能意味着直接从内部调用 CMS、数据库或其他 API <code>getServerSideProps</code>。</p><h2 id="在客户端获取数据" tabindex="-1"><a class="header-anchor" href="#在客户端获取数据" aria-hidden="true">#</a> 在客户端获取数据</h2><p>如果您的页面包含频繁更新的数据，并且您不需要预先渲染数据，您可以在客户端获取数据。这方面的一个例子是用户特定的数据：</p><ul><li>首先，立即显示没有数据的页面。页面的某些部分可以使用静态生成进行预渲染。您可以显示缺失数据的加载状态</li><li>然后，在客户端获取数据并在准备好时显示它</li></ul><p>例如，这种方法适用于用户仪表板页面。因为仪表板是私有的、特定于用户的页面，所以 SEO 不相关，并且该页面不需要预渲染。数据经常更新，这需要在请求时获取数据。</p><h2 id="使用-getserversideprops-在请求时获取数据" tabindex="-1"><a class="header-anchor" href="#使用-getserversideprops-在请求时获取数据" aria-hidden="true">#</a> 使用 getServerSideProps 在请求时获取数据</h2><p>以下示例显示了如何在请求时获取数据并预渲染结果。</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Page</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> data <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Render data...</span>
<span class="token punctuation">}</span>

<span class="token comment">// This gets called on every request</span>
<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getServerSideProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Fetch data from external API</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">https://.../data</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// Pass data to the page via props</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Page
</code></pre></div><h2 id="使用服务器端渲染-ssr-进行缓存" tabindex="-1"><a class="header-anchor" href="#使用服务器端渲染-ssr-进行缓存" aria-hidden="true">#</a> 使用服务器端渲染 (SSR) 进行缓存</h2><p>您可以在 getServerSideProps 中使用缓存标头 (<code>Cache-Control</code>) 来缓存动态响应。 例如，使用 <code>stale-while-revalidate</code>。</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// This value is considered fresh for ten seconds (s-maxage=10).</span>
<span class="token comment">// If a request is repeated within the next 10 seconds, the previously</span>
<span class="token comment">// cached value will still be fresh. If the request is repeated before 59 seconds,</span>
<span class="token comment">// the cached value will be stale but still render (stale-while-revalidate=59).</span>
<span class="token comment">//</span>
<span class="token comment">// In the background, a revalidation request will be made to populate the cache</span>
<span class="token comment">// with a fresh value. If you refresh the page, you will see the new value.</span>
<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getServerSideProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> req<span class="token punctuation">,</span> res <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span>
    <span class="token string">&#39;Cache-Control&#39;</span><span class="token punctuation">,</span>
    <span class="token string">&#39;public, s-maxage=10, stale-while-revalidate=59&#39;</span>
  <span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Learn more about caching.</p><h2 id="getserversideprops-是否呈现错误页面" tabindex="-1"><a class="header-anchor" href="#getserversideprops-是否呈现错误页面" aria-hidden="true">#</a> getServerSideProps 是否呈现错误页面</h2><p>如果内部抛出错误<code>getServerSideProps</code>，它将显示该<code>pages/500.js</code>文件。查看500 页的文档以了解有关如何创建它的更多信息。在开发过程中，不会使用此文件，而是显示 dev 覆盖。</p>`,31),o=[p];function r(c,d){return s(),a("div",null,o)}const l=e(t,[["render",r],["__file","get-server-side-props.html.vue"]]);export{l as default};
