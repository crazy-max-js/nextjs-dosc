import{_ as o,r as i,o as r,c as s,b as e,d as t,e as n,a as d}from"./app.1ad2624e.js";const c={},l=d(`<h1 id="automatic-static-optimization" tabindex="-1"><a class="header-anchor" href="#automatic-static-optimization" aria-hidden="true">#</a> Automatic Static Optimization</h1><p>Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of<code>getServerSideProps</code>and<code>getInitialProps</code>in the page.</p><p>This feature allows Next.js to emit hybrid applications that contain<strong>both server-rendered and statically generated pages</strong>.</p><blockquote><p>Statically generated pages are still reactive: Next.js will hydrate your application client-side to give it full interactivity.</p></blockquote><p>One of the main benefits of this feature is that optimized pages require no server-side computation, and can be instantly streamed to the end-user from multiple CDN locations. The result is anultra fastloading experience for your users.</p><h2 id="how-it-works" tabindex="-1"><a class="header-anchor" href="#how-it-works" aria-hidden="true">#</a> How it works</h2><p>If<code>getServerSideProps</code>or<code>getInitialProps</code>is present in a page, Next.js will switch to render the page on-demand, per-request (meaning<a href="/docs/guide/basic-features/pages#server-side-rendering">Server-Side Rendering</a>).</p><p>If the above is not the case, Next.js will<strong>statically optimize</strong>your page automatically by prerendering the page to static HTML.</p><p>During prerendering, the router&#39;s<code>query</code>object will be empty since we do not have<code>query</code>information to provide during this phase. After hydration, Next.js will trigger an update to your application to provide the route parameters in the<code>query</code>object.</p><p>The cases where the query will be updated after hydration triggering another render are:</p><ul><li>The page is a<a href="/docs/guide/routing/dynamic-routes">dynamic-route</a>.- The page has query values in the URL.- <a href="/docs/guide/api-reference/next.config.js/rewrites">Rewrites</a>are configured in your<code>next.config.js</code>since these can have parameters that may need to be parsed and provided in the<code>query</code>.</li></ul><p>To be able to distinguish if the query is fully updated and ready for use, you can leverage the<code>isReady</code>field on<a href="/docs/guide/api-reference/next/router#router-object"><code>next/router</code></a>.</p><blockquote><p>**Note:**Parameters added with<a href="/docs/guide/routing/dynamic-routes">dynamic routes</a>to a page that&#39;s using<a href="/docs/guide/basic-features/data-fetching/get-static-props"><code>getStaticProps</code></a>will always be available inside the<code>query</code>object.</p></blockquote><p><code>next build</code>will emit<code>.html</code>files for statically optimized pages. For example, the result for the page<code>pages/about.js</code>would be:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>.next/server/pages/about.html

</code></pre></div><p>And if you add<code>getServerSideProps</code>to the page, it will then be JavaScript, like so:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>.next/server/pages/about.js

</code></pre></div><h2 id="caveats" tabindex="-1"><a class="header-anchor" href="#caveats" aria-hidden="true">#</a> Caveats</h2>`,18),u=e("a",{href:"/docs/guide/advanced-features/custom-app"},[t("custom"),e("code",null,"App")],-1),h=e("code",null,"getInitialProps",-1),p=e("a",{href:"/docs/guide/basic-features/data-fetching/get-static-props"},"Static Generation",-1),g=e("a",{href:"/docs/guide/advanced-features/custom-document"},[t("custom"),e("code",null,"Document")],-1),f=e("code",null,"getInitialProps",-1),m=e("code",null,"ctx.req",-1),b=e("code",null,"ctx.req",-1),_=e("code",null,"undefined",-1),y=e("code",null,"asPath",-1),v=e("a",{href:"/docs/guide/api-reference/next/router#router-object"},[e("code",null,"next/router")],-1),x=e("code",null,"isReady",-1),w=e("code",null,"true",-1),q=e("code",null,"asPath",-1),j={href:"https://github.com/vercel/next.js/tree/canary/examples/active-class-name",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"active-class-name",-1),S=e("code",null,"asPath",-1);function N(P,z){const a=i("ExternalLinkIcon");return r(),s("div",null,[l,e("ul",null,[e("li",null,[t("If you have a"),u,t("with"),h,t("then this optimization will be turned off in pages without"),p,t(".- If you have a"),g,t("with"),f,t("be sure you check if"),m,t("is defined before assuming the page is server-side rendered."),b,t("will be"),_,t("for pages that are prerendered.- Avoid using the"),y,t("value on"),v,t("in the rendering tree until the router's"),x,t("field is"),w,t(". Statically optimized pages only know"),q,t("on the client and not the server, so using it as a prop may lead to mismatch errors. The"),e("a",j,[k,t("example"),n(a)]),t("demonstrates one way to use"),S,t("as a prop.")])])])}const T=o(c,[["render",N],["__file","automatic-static-optimization.html.vue"]]);export{T as default};
